// /shared/types.ts
// Canonical shared contracts for ClautechBarCodeGenerator.
// - Safe for import from BOTH renderer and main process
// - No Electron usage, no UI logic, deterministic structures

export type Symbology = "qr" | "datamatrix" | "code128";
export type Unit = "in" | "mm";

/**
 * Physical size + DPI (DPI is placed here because it participates in pixel math).
 * - width/height are in `unit`
 * - dpi is integer dots-per-inch
 */
export interface PhysicalSize {
  unit: Unit;
  width: number;
  height: number;
  dpi: number;
}

/**
 * Margin / quiet zone / padding around the code.
 *
 * IMPORTANT CONTRACT:
 * - margin is expressed in the SAME unit as `size.unit`
 * - later modules must not redefine this; convert to pixels via shared/units.ts
 */
export interface Margin {
  value: number; // in the same unit as Job.size.unit
}

/**
 * Job = everything required to generate/export an image deterministically.
 * Payload is required here; presets/templates may omit/derive it.
 */
export interface Job {
  id: string; // stable identifier (uuid/ulid/etc. generated by caller)
  symbology: Symbology;
  payload: string;

  size: PhysicalSize;
  margin: Margin;

  /** ISO strings (e.g. new Date().toISOString()) */
  createdAt: string;
  updatedAt: string;
}

/**
 * Job defaults for presets (payload typically user-entered, so it is optional here).
 * We exclude timestamps and id because those are instance-specific.
 */
export type JobDefaults = Omit<Job, "id" | "createdAt" | "updatedAt" | "payload"> & {
  payload?: string;
};

/**
 * Preset = named saved defaults a user can quickly apply.
 */
export interface Preset {
  id: string;
  name: string;
  jobDefaults: JobDefaults;
  createdAt: string; // ISO string
  updatedAt: string; // ISO string
}

/**
 * History item = snapshot of a full job at the moment it was generated.
 * savedPath can be attached after a Save As operation.
 */
export interface HistoryItem {
  id: string;
  timestamp: string; // ISO string at generation time
  jobSnapshot: Job;
  savedPath?: string;
}

/**
 * Template fields describe how to fill a pattern like:
 *   "PN:{partNumber};LOT:{lot};QTY:{qty}"
 * where tokens are "{partNumber}", "{lot}", "{qty}"
 */
export type TemplateFieldType = "string" | "number";

export interface TemplateField {
  /** Must match token name inside { } */
  name: string;
  label: string;

  required: boolean;
  type: TemplateFieldType;

  defaultValue?: string;

  /** Optional validation hints for future validation module */
  maxLength?: number;
  pattern?: string; // string form regex (e.g. "^[A-Z0-9]+$")
  description?: string;
}

export interface Template {
  id: string;
  name: string;

  /**
   * Pattern containing tokens like "{fieldName}".
   * Token substitution logic belongs in a later (non-shared) module;
   * the shared layer defines the contract only.
   */
  pattern: string;

  fields: TemplateField[];

  createdAt: string; // ISO string
  updatedAt: string; // ISO string
}

/**
 * Standardized app error structure (optional but recommended).
 * Validation module can produce these; generator/export modules can return them.
 */
export type AppErrorCode =
  | "INVALID_INPUT"
  | "UNSUPPORTED_SYMBOLOGY"
  | "GENERATION_FAILED"
  | "EXPORT_FAILED"
  | "INTERNAL_ERROR";

export interface AppError {
  code: AppErrorCode;
  message: string;
  details?: Record<string, unknown>;
}

/**
 * Result helper for consistent, typed error handling without throwing.
 * (Shared math utilities DO throw on invalid numeric inputs by contract.)
 */
export type Result<T> = { ok: true; value: T } | { ok: false; error: AppError };

/**
 * Save As result for Electron "Save As..." flows.
 *
 * CONTRACT:
 * - Cancel is not an error; it must be represented explicitly (never throw for cancel).
 * - Failures should be returned as a typed AppError (avoid throwing across IPC).
 */
export type SaveAsResult =
  | { ok: true; path: string }
  | { ok: false; reason: "canceled" }
  | { ok: false; reason: "error"; error: AppError };
